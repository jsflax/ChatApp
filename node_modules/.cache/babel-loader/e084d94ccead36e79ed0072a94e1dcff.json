{"ast":null,"code":"import _get from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _toConsumableArray from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _possibleConstructorReturn from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { usersCollection, channelSubscriptionsCollection, channelMessagesCollection } from \".\";\n/**\n * The customer user object relative to our Stitch user that contains\n * extended profile information.\n * \n * @param id {String}\n * @param name {String}\n * @param defaultAvatarOrdinal {Number} 0-7\n * @param avatar {ByteArray}\n * @param channelsSubscribedTo {StringArray}\n */\n\nexport function User(_id, name, defaultAvatarOrdinal, avatar, channelsSubscribedTo) {\n  return {\n    _id: _id,\n    name: name,\n    defaultAvatarOrdinal: defaultAvatarOrdinal,\n    avatar: avatar,\n    channelsSubscribedTo: channelsSubscribedTo\n  };\n} // define a class\n\nexport var Observable =\n/*#__PURE__*/\nfunction () {\n  // each instance of the Observer class\n  // starts with an empty array of things (observers)\n  // that react to a state change\n  function Observable() {\n    _classCallCheck(this, Observable);\n\n    this.observers = [];\n  } // add the ability to subscribe to a new object / DOM element\n  // essentially, add something to the observers array\n\n\n  _createClass(Observable, [{\n    key: \"subscribe\",\n    value: function subscribe(f) {\n      this.observers.push(f);\n    } // add the ability to unsubscribe from a particular object\n    // essentially, remove something from the observers array\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(f) {\n      this.observers = this.observers.filter(function (subscriber) {\n        return subscriber !== f;\n      });\n    } // update all subscribed objects / DOM elements\n    // and pass some data to each of them\n\n  }, {\n    key: \"notify\",\n    value: function notify(data) {\n      this.observers.forEach(function (observer) {\n        return observer(data);\n      });\n    }\n  }]);\n\n  return Observable;\n}();\nexport var UserObserver =\n/*#__PURE__*/\nfunction (_Observable) {\n  _inherits(UserObserver, _Observable);\n\n  function UserObserver() {\n    _classCallCheck(this, UserObserver);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UserObserver).call(this));\n  }\n\n  _createClass(UserObserver, [{\n    key: \"configure\",\n    value: function () {\n      var _configure = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return usersCollection.watch(localStorage.getItem(\"user_ids\"));\n\n              case 2:\n                this.stream = _context.sent;\n                this.stream.onNext(this.notify);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function configure() {\n        return _configure.apply(this, arguments);\n      }\n\n      return configure;\n    }()\n  }, {\n    key: \"sync\",\n    value: function () {\n      var _sync = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(ids) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.stream.close();\n                _context2.next = 3;\n                return usersCollection.find({\n                  _id: {\n                    $in: ids\n                  }\n                }).asArray;\n\n              case 3:\n                _context2.t0 = function (user) {\n                  localStorage.setItem(\"users:\" + user._id, user);\n                  var idsList = localStorage.getItem(\"user_ids\");\n                  idsList.push.apply(idsList, _toConsumableArray(ids));\n                  localStorage.setItem(\"user_ids\", idsList);\n                };\n\n                _context2.sent.forEach(_context2.t0);\n\n                _context2.next = 7;\n                return usersCollection.watch(localStorage.getItem(\"user_ids\"));\n\n              case 7:\n                this.stream = _context2.sent;\n                this.stream.onNext(this.notify);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sync(_x) {\n        return _sync.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }]);\n\n  return UserObserver;\n}(Observable);\nexport var usersObserver = new UserObserver();\nexport function ChannelMessage(_id, ownerId, channelId, content, sentAt, remoteTimestamp) {\n  return {\n    _id: _id,\n    ownerId: ownerId,\n    channelId: channelId,\n    content: content,\n    sentAt: sentAt,\n    remoteTimestamp: remoteTimestamp\n  };\n}\nexport var ChannelMessageObserver =\n/*#__PURE__*/\nfunction (_Observable2) {\n  _inherits(ChannelMessageObserver, _Observable2);\n\n  function ChannelMessageObserver() {\n    _classCallCheck(this, ChannelMessageObserver);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ChannelMessageObserver).apply(this, arguments));\n  }\n\n  _createClass(ChannelMessageObserver, [{\n    key: \"sync\",\n    value: function () {\n      var _sync2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(ids) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.stream.close();\n                _context3.next = 3;\n                return channelMessagesCollection.find({\n                  _id: {\n                    $in: ids\n                  }\n                }).asArray;\n\n              case 3:\n                _context3.t0 = function (msg) {\n                  _this.notify({\n                    fullDocument: msg,\n                    operationType: \"insert\"\n                  });\n                };\n\n                _context3.sent.forEach(_context3.t0);\n\n                this.stream = channelMessagesCollection.watch(ids);\n                this.stream.onNext(this.notify);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function sync(_x2) {\n        return _sync2.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }]);\n\n  return ChannelMessageObserver;\n}(Observable);\nexport var channelMessageObserver = new ChannelMessageObserver();\nexport function ChannelSubscription(_id, channelId, ownerId, subscriptionId, localTimestamp, remoteTimestamp) {\n  return {\n    _id: _id,\n    channelId: channelId,\n    ownerId: ownerId,\n    deviceId: subscriptionId,\n    localTimestamp: localTimestamp,\n    remoteTimestamp: remoteTimestamp\n  };\n}\nexport var ChannelSubscriptionObserver =\n/*#__PURE__*/\nfunction (_Observable3) {\n  _inherits(ChannelSubscriptionObserver, _Observable3);\n\n  function ChannelSubscriptionObserver() {\n    _classCallCheck(this, ChannelSubscriptionObserver);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ChannelSubscriptionObserver).call(this));\n  }\n\n  _createClass(ChannelSubscriptionObserver, [{\n    key: \"updateLocalVector\",\n    value: function () {\n      var _updateLocalVector = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(documentId, subscription) {\n        var latestMessageIds;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return channelMessagesCollection.find({\n                  channelId: subscription.channelId,\n                  remoteTimestamp: {\n                    $gt: subscription.localTimestamp,\n                    $lte: subscription.remoteTimestamp\n                  }\n                }).asArray();\n\n              case 2:\n                _context4.t0 = function (it) {\n                  return it[\"_id\"];\n                };\n\n                latestMessageIds = _context4.sent.map(_context4.t0);\n                _context4.next = 6;\n                return channelMessageObserver.sync(latestMessageIds);\n\n              case 6:\n                _context4.next = 8;\n                return channelSubscriptionCollection.updateOne({\n                  _id: documentId\n                }, {\n                  $set: {\n                    localTimestamp: subscription.localTimestamp\n                  }\n                });\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function updateLocalVector(_x3, _x4) {\n        return _updateLocalVector.apply(this, arguments);\n      }\n\n      return updateLocalVector;\n    }()\n  }, {\n    key: \"notify\",\n    value: function notify(data) {\n      var subscription = data.fullDocument;\n\n      if (event.hasUncommittedWrites() || event.operationType != OperationType.REPLACE || subscription == null || subscription.localTimestamp == subscription.remoteTimestamp) {\n        return;\n      }\n\n      updateLocalVector(documentId, subscription);\n\n      _get(_getPrototypeOf(ChannelSubscriptionObserver.prototype), \"notify\", this).call(this, data);\n    }\n  }, {\n    key: \"configure\",\n    value: function () {\n      var _configure2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return channelSubscriptionsCollection.watch(localStorage.getItem(\"user_ids\"));\n\n              case 2:\n                this.stream = _context5.sent;\n                this.stream.onNext(this.notify);\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function configure() {\n        return _configure2.apply(this, arguments);\n      }\n\n      return configure;\n    }()\n  }, {\n    key: \"sync\",\n    value: function () {\n      var _sync3 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(ids) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this.stream.close();\n                _context6.next = 3;\n                return channelSubscriptionsCollection.find({\n                  _id: {\n                    $in: ids\n                  }\n                }).asArray;\n\n              case 3:\n                _context6.t0 = function (user) {\n                  localStorage.setItem(\"channelSubscriptions:\" + user._id, user);\n                  var idsList = localStorage.getItem(\"user_ids\");\n                  idsList.push.apply(idsList, _toConsumableArray(ids));\n                  localStorage.setItem(\"user_ids\", idsList);\n                };\n\n                _context6.sent.forEach(_context6.t0);\n\n                _context6.next = 7;\n                return channelSubscriptionsCollection.watch(localStorage.getItem(\"user_ids\"));\n\n              case 7:\n                this.stream = _context6.sent;\n                this.stream.onNext(this.notify);\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function sync(_x5) {\n        return _sync3.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }]);\n\n  return ChannelSubscriptionObserver;\n}(Observable);\nexport var channelSubscriptionObserver = new ChannelSubscriptionObserver();","map":{"version":3,"sources":["/Users/jasonflax/Development/ChatApp/src/models.js"],"names":["usersCollection","channelSubscriptionsCollection","channelMessagesCollection","User","_id","name","defaultAvatarOrdinal","avatar","channelsSubscribedTo","Observable","observers","f","push","filter","subscriber","data","forEach","observer","UserObserver","watch","localStorage","getItem","stream","onNext","notify","ids","close","find","$in","asArray","user","setItem","idsList","usersObserver","ChannelMessage","ownerId","channelId","content","sentAt","remoteTimestamp","ChannelMessageObserver","msg","fullDocument","operationType","channelMessageObserver","ChannelSubscription","subscriptionId","localTimestamp","deviceId","ChannelSubscriptionObserver","documentId","subscription","$gt","$lte","it","latestMessageIds","map","sync","channelSubscriptionCollection","updateOne","$set","event","hasUncommittedWrites","OperationType","REPLACE","updateLocalVector","channelSubscriptionObserver"],"mappings":"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","sourcesContent":["import { usersCollection, channelSubscriptionsCollection, channelMessagesCollection } from \".\";\n\n/**\n * The customer user object relative to our Stitch user that contains\n * extended profile information.\n * \n * @param id {String}\n * @param name {String}\n * @param defaultAvatarOrdinal {Number} 0-7\n * @param avatar {ByteArray}\n * @param channelsSubscribedTo {StringArray}\n */\nexport function User(_id, name, defaultAvatarOrdinal, avatar, channelsSubscribedTo) {\n\treturn {\n\t\t_id, name, defaultAvatarOrdinal, avatar, channelsSubscribedTo\n\t};\n}\n\n// define a class\nexport class Observable {\n\t// each instance of the Observer class\n\t// starts with an empty array of things (observers)\n\t// that react to a state change\n\tconstructor() {\n\t  this.observers = [];\n\t}\n  \n\t// add the ability to subscribe to a new object / DOM element\n\t// essentially, add something to the observers array\n\tsubscribe(f) {\n\t  this.observers.push(f);\n\t}\n  \n\t// add the ability to unsubscribe from a particular object\n\t// essentially, remove something from the observers array\n\tunsubscribe(f) {\n\t  this.observers = this.observers.filter(subscriber => subscriber !== f);\n\t}\n  \n\t// update all subscribed objects / DOM elements\n\t// and pass some data to each of them\n\tnotify(data) {\n\t  this.observers.forEach(observer => observer(data));\n\t}\n  }\n\nexport class UserObserver extends Observable {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tasync configure() {\n\t\tthis.stream = await usersCollection.watch(localStorage.getItem(\"user_ids\"));\n\t\tthis.stream.onNext(this.notify);\n\t}\n\n\tasync sync(ids) {\n\t\tthis.stream.close();\n\t\t(await usersCollection.find({_id: { $in: ids }}).asArray).forEach((user) => {\n\t\t\tlocalStorage.setItem(\"users:\" + user._id, user);\n\t\t\tconst idsList = localStorage.getItem(\"user_ids\");\n\t\t\tidsList.push(...ids);\n\t\t\tlocalStorage.setItem(\"user_ids\", idsList);\n\t\t});\n\t\tthis.stream = await usersCollection.watch(localStorage.getItem(\"user_ids\"));\n\t\tthis.stream.onNext(this.notify);\n\t}\n}\n\nexport const usersObserver = new UserObserver();\n\nexport function ChannelMessage(_id, ownerId, channelId, content, sentAt, remoteTimestamp) {\n\treturn { _id, ownerId, channelId, content, sentAt, remoteTimestamp };\n}\n\nexport class ChannelMessageObserver extends Observable {\n\tasync sync(ids) {\n\t\tthis.stream.close();\n\t\t(await channelMessagesCollection.find({_id: { $in: ids }}).asArray).forEach((msg) => {\n\t\t\tthis.notify({fullDocument: msg, operationType: \"insert\"})\n\t\t});\n\t\tthis.stream = channelMessagesCollection.watch(ids);\n\t\tthis.stream.onNext(this.notify);\n\t}\n}\n\nexport const channelMessageObserver = new ChannelMessageObserver();\n\nexport function ChannelSubscription(_id, channelId, ownerId, subscriptionId, localTimestamp, remoteTimestamp) {\n\treturn {\n\t\t_id, channelId, ownerId, deviceId: subscriptionId, localTimestamp, remoteTimestamp \n\t};\n}\n\nexport class ChannelSubscriptionObserver extends Observable {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tasync updateLocalVector(documentId, subscription) {\n\t\t// fetch latest message ids from logical time vector\n        const latestMessageIds = (await channelMessagesCollection.find({\n                    channelId: subscription.channelId,\n                    remoteTimestamp: {\n                        $gt: subscription.localTimestamp,\n                        $lte: subscription.remoteTimestamp\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.asArray())\n\t\t\t\t.map(it => it[\"_id\"])\n\t\t\t\t\n        await channelMessageObserver.sync(latestMessageIds)\n\n        await channelSubscriptionCollection.updateOne(\n            { _id: documentId },\n            { $set : { localTimestamp: subscription.localTimestamp }}\n        )\n\t}\n\n\tnotify(data) {\n\t\tconst subscription = data.fullDocument\n\n        if (event.hasUncommittedWrites()\n            || event.operationType != OperationType.REPLACE\n            || subscription == null\n            || subscription.localTimestamp == subscription.remoteTimestamp) {\n            return\n        }\n\n        updateLocalVector(documentId, subscription)\n\n\t\tsuper.notify(data);\n\t}\n\n\tasync configure() {\n\t\tthis.stream = await channelSubscriptionsCollection.watch(localStorage.getItem(\"user_ids\"));\n\t\tthis.stream.onNext(this.notify);\n\t}\n\n\tasync sync(ids) {\n\t\tthis.stream.close();\n\t\t(await channelSubscriptionsCollection.find({_id: { $in: ids }}).asArray).forEach((user) => {\n\t\t\tlocalStorage.setItem(\"channelSubscriptions:\" + user._id, user);\n\t\t\tconst idsList = localStorage.getItem(\"user_ids\");\n\t\t\tidsList.push(...ids);\n\t\t\tlocalStorage.setItem(\"user_ids\", idsList);\n\t\t});\n\t\tthis.stream = await channelSubscriptionsCollection.watch(localStorage.getItem(\"user_ids\"));\n\t\tthis.stream.onNext(this.notify);\n\t}\n}\n\nexport const channelSubscriptionObserver = new ChannelSubscriptionObserver();"]},"metadata":{},"sourceType":"module"}