{"ast":null,"code":"import _get from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _regeneratorRuntime from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _possibleConstructorReturn from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { usersCollection, channelSubscriptionsCollection, channelMessagesCollection } from \".\";\nimport { EJSON } from \"bson\";\n/**\n * The customer user object relative to our Stitch user that contains\n * extended profile information.\n * \n * @param id {String}\n * @param name {String}\n * @param defaultAvatarOrdinal {Number} 0-7\n * @param avatar {ByteArray}\n * @param channelsSubscribedTo {StringArray}\n */\n\nexport function User(_id, name, defaultAvatarOrdinal, avatar, channelsSubscribedTo) {\n  return {\n    _id: _id,\n    name: name,\n    defaultAvatarOrdinal: defaultAvatarOrdinal,\n    avatar: avatar,\n    channelsSubscribedTo: channelsSubscribedTo\n  };\n} // define a class\n\nexport var Observable =\n/*#__PURE__*/\nfunction () {\n  // each instance of the Observer class\n  // starts with an empty array of things (observers)\n  // that react to a state change\n  function Observable() {\n    _classCallCheck(this, Observable);\n\n    this.observers = [];\n  } // add the ability to subscribe to a new object / DOM element\n  // essentially, add something to the observers array\n\n\n  _createClass(Observable, [{\n    key: \"subscribe\",\n    value: function subscribe(f) {\n      this.observers.push(f);\n    } // add the ability to unsubscribe from a particular object\n    // essentially, remove something from the observers array\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(f) {\n      this.observers = this.observers.filter(function (subscriber) {\n        return subscriber !== f;\n      });\n    } // update all subscribed objects / DOM elements\n    // and pass some data to each of them\n\n  }, {\n    key: \"notify\",\n    value: function notify(data) {\n      this.observers.forEach(function (observer) {\n        return observer(data);\n      });\n    }\n  }]);\n\n  return Observable;\n}();\nexport var UserObserver =\n/*#__PURE__*/\nfunction (_Observable) {\n  _inherits(UserObserver, _Observable);\n\n  function UserObserver() {\n    _classCallCheck(this, UserObserver);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UserObserver).call(this));\n  }\n\n  _createClass(UserObserver, [{\n    key: \"configure\",\n    value: function () {\n      var _configure = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var userIds;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (localStorage.getItem(\"user_ids\")) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                userIds = EJSON.deserialize(localStorage.getItem(\"user_ids\"));\n                console.log(userIds);\n                _context.next = 6;\n                return usersCollection.watch([userIds]);\n\n              case 6:\n                this.stream = _context.sent;\n                this.stream.onNext(this.notify);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function configure() {\n        return _configure.apply(this, arguments);\n      }\n\n      return configure;\n    }()\n  }, {\n    key: \"sync\",\n    value: function () {\n      var _sync = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(id) {\n        var userIds, user;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.stream) {\n                  this.stream.close();\n                }\n\n                userIds = [];\n\n                if (localStorage.getItem(\"user_ids\")) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                userIds = [];\n                _context2.next = 9;\n                break;\n\n              case 6:\n                if (!(EJSON.deserialize(localStorage.getItem(\"user_ids\")) == id)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                console.log(\"found it!\");\n                return _context2.abrupt(\"return\", localStorage.getItem(\"users.\" + id));\n\n              case 9:\n                _context2.next = 11;\n                return usersCollection.find({\n                  _id: id\n                }).first();\n\n              case 11:\n                user = _context2.sent;\n                console.log(user);\n                localStorage.setItem(\"users.\" + id, EJSON.serialize(user));\n                userIds.push(id);\n                localStorage.setItem(\"user_ids\", EJSON.serialize(userIds));\n                console.log(userIds);\n                _context2.next = 19;\n                return usersCollection.watch(userIds);\n\n              case 19:\n                this.stream = _context2.sent;\n                this.stream.onNext(this.notify);\n                return _context2.abrupt(\"return\", user);\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sync(_x) {\n        return _sync.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }]);\n\n  return UserObserver;\n}(Observable);\nexport var usersObserver = new UserObserver();\nexport function ChannelMessage(_id, ownerId, channelId, content, sentAt, remoteTimestamp) {\n  return {\n    _id: _id,\n    ownerId: ownerId,\n    channelId: channelId,\n    content: content,\n    sentAt: sentAt,\n    remoteTimestamp: remoteTimestamp\n  };\n}\nexport var ChannelMessageObserver =\n/*#__PURE__*/\nfunction (_Observable2) {\n  _inherits(ChannelMessageObserver, _Observable2);\n\n  function ChannelMessageObserver() {\n    _classCallCheck(this, ChannelMessageObserver);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ChannelMessageObserver).apply(this, arguments));\n  }\n\n  _createClass(ChannelMessageObserver, [{\n    key: \"sync\",\n    value: function () {\n      var _sync2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(ids) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.stream) {\n                  this.stream.close();\n                }\n\n                _context3.next = 3;\n                return channelMessagesCollection.find({\n                  _id: {\n                    $in: ids\n                  }\n                }).asArray();\n\n              case 3:\n                _context3.t0 = function (msg) {\n                  _this.notify({\n                    fullDocument: msg,\n                    operationType: \"insert\"\n                  });\n                };\n\n                _context3.sent.forEach(_context3.t0);\n\n                _context3.next = 7;\n                return channelMessagesCollection.watch(ids);\n\n              case 7:\n                this.stream = _context3.sent;\n                this.stream.onNext(this.notify);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function sync(_x2) {\n        return _sync2.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }]);\n\n  return ChannelMessageObserver;\n}(Observable);\nexport var channelMessageObserver = new ChannelMessageObserver();\nexport function ChannelSubscription(_id, channelId, ownerId, subscriptionId, localTimestamp, remoteTimestamp) {\n  return {\n    _id: _id,\n    channelId: channelId,\n    ownerId: ownerId,\n    deviceId: subscriptionId,\n    localTimestamp: localTimestamp,\n    remoteTimestamp: remoteTimestamp\n  };\n}\nexport var ChannelSubscriptionObserver =\n/*#__PURE__*/\nfunction (_Observable3) {\n  _inherits(ChannelSubscriptionObserver, _Observable3);\n\n  function ChannelSubscriptionObserver() {\n    _classCallCheck(this, ChannelSubscriptionObserver);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ChannelSubscriptionObserver).call(this));\n  }\n\n  _createClass(ChannelSubscriptionObserver, [{\n    key: \"updateLocalVector\",\n    value: function () {\n      var _updateLocalVector = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(documentId, subscription) {\n        var latestMessageIds;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return channelMessagesCollection.find({\n                  channelId: subscription.channelId,\n                  remoteTimestamp: {\n                    $gt: subscription.localTimestamp,\n                    $lte: subscription.remoteTimestamp\n                  }\n                }).asArray();\n\n              case 2:\n                _context4.t0 = function (it) {\n                  return it[\"_id\"];\n                };\n\n                latestMessageIds = _context4.sent.map(_context4.t0);\n                _context4.next = 6;\n                return channelMessageObserver.sync(latestMessageIds);\n\n              case 6:\n                _context4.next = 8;\n                return channelSubscriptionsCollection.updateOne({\n                  _id: documentId\n                }, {\n                  $set: {\n                    localTimestamp: subscription.localTimestamp\n                  }\n                });\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function updateLocalVector(_x3, _x4) {\n        return _updateLocalVector.apply(this, arguments);\n      }\n\n      return updateLocalVector;\n    }()\n  }, {\n    key: \"notify\",\n    value: function () {\n      var _notify = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(data) {\n        var subscription;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                subscription = data.fullDocument;\n\n                if (!(data.operationType != \"insert\" || subscription == null || subscription.localTimestamp == subscription.remoteTimestamp)) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 3:\n                _context5.next = 5;\n                return this.updateLocalVector(data.documentKey[\"_id\"], subscription);\n\n              case 5:\n                _get(_getPrototypeOf(ChannelSubscriptionObserver.prototype), \"notify\", this).call(this, data);\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function notify(_x5) {\n        return _notify.apply(this, arguments);\n      }\n\n      return notify;\n    }()\n  }, {\n    key: \"sync\",\n    value: function () {\n      var _sync3 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(id) {\n        var sub;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return channelSubscriptionsCollection.find({\n                  _id: id\n                }).first();\n\n              case 2:\n                sub = _context6.sent;\n                _context6.next = 5;\n                return this.updateLocalVector(id, sub);\n\n              case 5:\n                _context6.next = 7;\n                return channelSubscriptionsCollection.watch([id]);\n\n              case 7:\n                this.stream = _context6.sent;\n                this.stream.onNext(this.notify);\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function sync(_x6) {\n        return _sync3.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }]);\n\n  return ChannelSubscriptionObserver;\n}(Observable);\nexport var channelSubscriptionObserver = new ChannelSubscriptionObserver();","map":{"version":3,"sources":["/Users/jasonflax/Development/ChatApp/src/models.js"],"names":["usersCollection","channelSubscriptionsCollection","channelMessagesCollection","EJSON","User","_id","name","defaultAvatarOrdinal","avatar","channelsSubscribedTo","Observable","observers","f","push","filter","subscriber","data","forEach","observer","UserObserver","localStorage","getItem","userIds","deserialize","console","log","watch","stream","onNext","notify","id","close","find","first","user","setItem","serialize","usersObserver","ChannelMessage","ownerId","channelId","content","sentAt","remoteTimestamp","ChannelMessageObserver","ids","$in","asArray","msg","fullDocument","operationType","channelMessageObserver","ChannelSubscription","subscriptionId","localTimestamp","deviceId","ChannelSubscriptionObserver","documentId","subscription","$gt","$lte","it","latestMessageIds","map","sync","updateOne","$set","updateLocalVector","documentKey","sub","channelSubscriptionObserver"],"mappings":"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","sourcesContent":["import { usersCollection, channelSubscriptionsCollection, channelMessagesCollection } from \".\";\nimport { EJSON } from \"bson\";\n\n/**\n * The customer user object relative to our Stitch user that contains\n * extended profile information.\n * \n * @param id {String}\n * @param name {String}\n * @param defaultAvatarOrdinal {Number} 0-7\n * @param avatar {ByteArray}\n * @param channelsSubscribedTo {StringArray}\n */\nexport function User(_id, name, defaultAvatarOrdinal, avatar, channelsSubscribedTo) {\n\treturn {\n\t\t_id, name, defaultAvatarOrdinal, avatar, channelsSubscribedTo\n\t};\n}\n\n// define a class\nexport class Observable {\n\t// each instance of the Observer class\n\t// starts with an empty array of things (observers)\n\t// that react to a state change\n\tconstructor() {\n\t  this.observers = [];\n\t}\n  \n\t// add the ability to subscribe to a new object / DOM element\n\t// essentially, add something to the observers array\n\tsubscribe(f) {\n\t  this.observers.push(f);\n\t}\n  \n\t// add the ability to unsubscribe from a particular object\n\t// essentially, remove something from the observers array\n\tunsubscribe(f) {\n\t  this.observers = this.observers.filter(subscriber => subscriber !== f);\n\t}\n  \n\t// update all subscribed objects / DOM elements\n\t// and pass some data to each of them\n\tnotify(data) {\n\t  this.observers.forEach(observer => observer(data));\n\t}\n  }\n\nexport class UserObserver extends Observable {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tasync configure() {\n\t\tif (!localStorage.getItem(\"user_ids\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst userIds = EJSON.deserialize(localStorage.getItem(\"user_ids\"));\n\t\tconsole.log(userIds);\n\t\tthis.stream = await usersCollection.watch([userIds]);\n\t\tthis.stream.onNext(this.notify);\n\t}\n\n\tasync sync(id) {\n\t\tif (this.stream) {\n\t\t\tthis.stream.close();\n\t\t}\n\t\tlet userIds = [];\n\t\tif (!localStorage.getItem(\"user_ids\")) {\n\t\t\tuserIds = []\n\t\t} else if (EJSON.deserialize(localStorage.getItem(\"user_ids\")) == id) {\n\t\t\tconsole.log(\"found it!\")\n\t\t\treturn localStorage.getItem(\"users.\" + id);\n\t\t}\n\n\t\tconst user = await usersCollection.find({_id: id}).first();\n\t\tconsole.log(user);\n\t\tlocalStorage.setItem(\"users.\" + id, EJSON.serialize(user));\n\t\tuserIds.push(id);\n\t\tlocalStorage.setItem(\"user_ids\", EJSON.serialize(userIds));\n\t\n\t\tconsole.log(userIds);\n\t\tthis.stream = await usersCollection.watch(userIds);\n\t\tthis.stream.onNext(this.notify);\n\t\treturn user;\n\t}\n}\n\nexport const usersObserver = new UserObserver();\n\nexport function ChannelMessage(_id, ownerId, channelId, content, sentAt, remoteTimestamp) {\n\treturn { _id, ownerId, channelId, content, sentAt, remoteTimestamp };\n}\n\nexport class ChannelMessageObserver extends Observable {\n\tasync sync(ids) {\n\t\tif (this.stream) {\n\t\t\tthis.stream.close();\n\t\t}\n\t\t(await channelMessagesCollection.find({_id: { $in: ids }}).asArray()).forEach((msg) => {\n\t\t\tthis.notify({fullDocument: msg, operationType: \"insert\"})\n\t\t});\n\t\tthis.stream = await channelMessagesCollection.watch(ids);\n\t\tthis.stream.onNext(this.notify);\n\t}\n}\n\nexport const channelMessageObserver = new ChannelMessageObserver();\n\nexport function ChannelSubscription(_id, channelId, ownerId, subscriptionId, localTimestamp, remoteTimestamp) {\n\treturn {\n\t\t_id, channelId, ownerId, deviceId: subscriptionId, localTimestamp, remoteTimestamp \n\t};\n}\n\nexport class ChannelSubscriptionObserver extends Observable {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tasync updateLocalVector(documentId, subscription) {\n\t\t// fetch latest message ids from logical time vector\n        const latestMessageIds = (await channelMessagesCollection.find({\n                    channelId: subscription.channelId,\n                    remoteTimestamp: {\n                        $gt: subscription.localTimestamp,\n                        $lte: subscription.remoteTimestamp\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.asArray())\n\t\t\t\t.map(it => it[\"_id\"])\n\t\t\t\t\n        await channelMessageObserver.sync(latestMessageIds)\n\n        await channelSubscriptionsCollection.updateOne(\n            { _id: documentId },\n            { $set : { localTimestamp: subscription.localTimestamp }}\n        )\n\t}\n\n\tasync notify(data) {\n\t\tconst subscription = data.fullDocument\n\n        if (data.operationType != \"insert\"\n            || subscription == null\n            || subscription.localTimestamp == subscription.remoteTimestamp) {\n            return\n        }\n\n        await this.updateLocalVector(data.documentKey[\"_id\"], subscription)\n\n\t\tsuper.notify(data);\n\t}\n\n\tasync sync(id) {\n\t\t// this.stream.close();\n\t\tconst sub = await channelSubscriptionsCollection.find({_id: id }).first();\n\t\tawait this.updateLocalVector(id, sub);\n\t\tthis.stream = await channelSubscriptionsCollection.watch([id]);\n\t\tthis.stream.onNext(this.notify);\n\t}\n}\n\nexport const channelSubscriptionObserver = new ChannelSubscriptionObserver();"]},"metadata":{},"sourceType":"module"}