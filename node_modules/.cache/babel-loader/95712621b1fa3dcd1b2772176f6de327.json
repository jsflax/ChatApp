{"ast":null,"code":"import _get from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _regeneratorRuntime from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _possibleConstructorReturn from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jasonflax/Development/ChatApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { usersCollection, channelSubscriptionsCollection, channelMessagesCollection } from \".\";\nimport { EJSON } from \"bson\";\nimport LRU from \"lru-cache\";\n/**\n * The customer user object relative to our Stitch user that contains\n * extended profile information.\n * \n * @param id {String}\n * @param name {String}\n * @param defaultAvatarOrdinal {Number} 0-7\n * @param avatar {ByteArray}\n * @param channelsSubscribedTo {StringArray}\n */\n\nexport function User(_id, name, defaultAvatarOrdinal, avatar, channelsSubscribedTo) {\n  return {\n    _id: _id,\n    name: name,\n    defaultAvatarOrdinal: defaultAvatarOrdinal,\n    avatar: avatar,\n    channelsSubscribedTo: channelsSubscribedTo\n  };\n} // define a class\n\nexport var Observable =\n/*#__PURE__*/\nfunction () {\n  // each instance of the Observer class\n  // starts with an empty array of things (observers)\n  // that react to a state change\n  function Observable() {\n    _classCallCheck(this, Observable);\n\n    this.observers = [];\n  } // add the ability to subscribe to a new object / DOM element\n  // essentially, add something to the observers array\n\n\n  _createClass(Observable, [{\n    key: \"subscribe\",\n    value: function subscribe(f) {\n      this.observers.push(f);\n    } // add the ability to unsubscribe from a particular object\n    // essentially, remove something from the observers array\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(f) {\n      this.observers = this.observers.filter(function (subscriber) {\n        return subscriber !== f;\n      });\n    } // update all subscribed objects / DOM elements\n    // and pass some data to each of them\n\n  }, {\n    key: \"notify\",\n    value: function notify(data) {\n      this.observers.forEach(function (observer) {\n        return observer(data);\n      });\n    }\n  }]);\n\n  return Observable;\n}();\nexport var UserObserver =\n/*#__PURE__*/\nfunction (_Observable) {\n  _inherits(UserObserver, _Observable);\n\n  function UserObserver() {\n    var _this;\n\n    _classCallCheck(this, UserObserver);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(UserObserver).call(this));\n    _this.cache = new LRU(50);\n    return _this;\n  }\n\n  _createClass(UserObserver, [{\n    key: \"sync\",\n    value: function () {\n      var _sync = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(id) {\n        var user;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.stream) {\n                  this.stream.close();\n                }\n\n                if (!this.cache.has(id)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.cache.get(id));\n\n              case 3:\n                _context.next = 5;\n                return usersCollection.find({\n                  _id: id\n                }).first();\n\n              case 5:\n                user = _context.sent;\n                this.cache.set(id, user);\n                console.log(this.cache.keys());\n                _context.next = 10;\n                return usersCollection.watch(this.cache.keys());\n\n              case 10:\n                this.stream = _context.sent;\n                this.stream.onNext(this.notify);\n                return _context.abrupt(\"return\", user);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sync(_x) {\n        return _sync.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }]);\n\n  return UserObserver;\n}(Observable);\nexport var usersObserver = new UserObserver();\nexport function ChannelMessage(_id, ownerId, channelId, content, sentAt, remoteTimestamp) {\n  return {\n    _id: _id,\n    ownerId: ownerId,\n    channelId: channelId,\n    content: content,\n    sentAt: sentAt,\n    remoteTimestamp: remoteTimestamp\n  };\n}\nexport var ChannelMessageObserver =\n/*#__PURE__*/\nfunction (_Observable2) {\n  _inherits(ChannelMessageObserver, _Observable2);\n\n  function ChannelMessageObserver() {\n    _classCallCheck(this, ChannelMessageObserver);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ChannelMessageObserver).apply(this, arguments));\n  }\n\n  _createClass(ChannelMessageObserver, [{\n    key: \"sync\",\n    value: function () {\n      var _sync2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(ids) {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.stream) {\n                  this.stream.close();\n                }\n\n                _context2.next = 3;\n                return channelMessagesCollection.find({\n                  _id: {\n                    $in: ids\n                  }\n                }).asArray();\n\n              case 3:\n                _context2.t0 = function (msg) {\n                  _this2.notify({\n                    fullDocument: msg,\n                    operationType: \"insert\"\n                  });\n                };\n\n                _context2.sent.forEach(_context2.t0);\n\n                _context2.next = 7;\n                return channelMessagesCollection.watch(ids);\n\n              case 7:\n                this.stream = _context2.sent;\n                this.stream.onNext(this.notify);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sync(_x2) {\n        return _sync2.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }]);\n\n  return ChannelMessageObserver;\n}(Observable);\nexport var channelMessageObserver = new ChannelMessageObserver();\nexport function ChannelSubscription(_id, channelId, ownerId, subscriptionId, localTimestamp, remoteTimestamp) {\n  return {\n    _id: _id,\n    channelId: channelId,\n    ownerId: ownerId,\n    deviceId: subscriptionId,\n    localTimestamp: localTimestamp,\n    remoteTimestamp: remoteTimestamp\n  };\n}\nexport var ChannelSubscriptionObserver =\n/*#__PURE__*/\nfunction (_Observable3) {\n  _inherits(ChannelSubscriptionObserver, _Observable3);\n\n  function ChannelSubscriptionObserver() {\n    _classCallCheck(this, ChannelSubscriptionObserver);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ChannelSubscriptionObserver).call(this));\n  }\n\n  _createClass(ChannelSubscriptionObserver, [{\n    key: \"updateLocalVector\",\n    value: function () {\n      var _updateLocalVector = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(documentId, subscription) {\n        var latestMessageIds;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return channelMessagesCollection.find({\n                  channelId: subscription.channelId,\n                  remoteTimestamp: {\n                    $gt: subscription.localTimestamp,\n                    $lte: subscription.remoteTimestamp\n                  }\n                }).asArray();\n\n              case 2:\n                _context3.t0 = function (it) {\n                  return it[\"_id\"];\n                };\n\n                latestMessageIds = _context3.sent.map(_context3.t0);\n                _context3.next = 6;\n                return channelMessageObserver.sync(latestMessageIds);\n\n              case 6:\n                _context3.next = 8;\n                return channelSubscriptionsCollection.updateOne({\n                  _id: documentId\n                }, {\n                  $set: {\n                    localTimestamp: subscription.localTimestamp\n                  }\n                });\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function updateLocalVector(_x3, _x4) {\n        return _updateLocalVector.apply(this, arguments);\n      }\n\n      return updateLocalVector;\n    }()\n  }, {\n    key: \"notify\",\n    value: function () {\n      var _notify = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(data) {\n        var subscription;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                console.log(\"New event!\");\n                console.log(data);\n                subscription = data.fullDocument;\n\n                if (!(data.operationType != \"insert\" || subscription == null || subscription.localTimestamp == subscription.remoteTimestamp)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 5:\n                _context4.next = 7;\n                return this.updateLocalVector(data.documentKey[\"_id\"], subscription);\n\n              case 7:\n                _get(_getPrototypeOf(ChannelSubscriptionObserver.prototype), \"notify\", this).call(this, data);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function notify(_x5) {\n        return _notify.apply(this, arguments);\n      }\n\n      return notify;\n    }()\n  }, {\n    key: \"sync\",\n    value: function () {\n      var _sync3 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(id) {\n        var _this3 = this;\n\n        var sub;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return channelSubscriptionsCollection.find({\n                  _id: id\n                }).first();\n\n              case 2:\n                sub = _context5.sent;\n                _context5.next = 5;\n                return this.updateLocalVector(id, sub);\n\n              case 5:\n                _context5.next = 7;\n                return channelSubscriptionsCollection.watch([id]);\n\n              case 7:\n                this.stream = _context5.sent;\n                this.stream.onNext(function (data) {\n                  _this3.notify(data);\n                });\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function sync(_x6) {\n        return _sync3.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }]);\n\n  return ChannelSubscriptionObserver;\n}(Observable);\nexport var channelSubscriptionObserver = new ChannelSubscriptionObserver();","map":{"version":3,"sources":["/Users/jasonflax/Development/ChatApp/src/models.js"],"names":["usersCollection","channelSubscriptionsCollection","channelMessagesCollection","EJSON","LRU","User","_id","name","defaultAvatarOrdinal","avatar","channelsSubscribedTo","Observable","observers","f","push","filter","subscriber","data","forEach","observer","UserObserver","cache","id","stream","close","has","get","find","first","user","set","console","log","keys","watch","onNext","notify","usersObserver","ChannelMessage","ownerId","channelId","content","sentAt","remoteTimestamp","ChannelMessageObserver","ids","$in","asArray","msg","fullDocument","operationType","channelMessageObserver","ChannelSubscription","subscriptionId","localTimestamp","deviceId","ChannelSubscriptionObserver","documentId","subscription","$gt","$lte","it","latestMessageIds","map","sync","updateOne","$set","updateLocalVector","documentKey","sub","channelSubscriptionObserver"],"mappings":"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","sourcesContent":["import { usersCollection, channelSubscriptionsCollection, channelMessagesCollection } from \".\";\nimport { EJSON } from \"bson\";\nimport LRU from \"lru-cache\";\n\n/**\n * The customer user object relative to our Stitch user that contains\n * extended profile information.\n * \n * @param id {String}\n * @param name {String}\n * @param defaultAvatarOrdinal {Number} 0-7\n * @param avatar {ByteArray}\n * @param channelsSubscribedTo {StringArray}\n */\nexport function User(_id, name, defaultAvatarOrdinal, avatar, channelsSubscribedTo) {\n\treturn {\n\t\t_id, name, defaultAvatarOrdinal, avatar, channelsSubscribedTo\n\t};\n}\n\n// define a class\nexport class Observable {\n\t// each instance of the Observer class\n\t// starts with an empty array of things (observers)\n\t// that react to a state change\n\tconstructor() {\n\t  this.observers = [];\n\t}\n  \n\t// add the ability to subscribe to a new object / DOM element\n\t// essentially, add something to the observers array\n\tsubscribe(f) {\n\t  this.observers.push(f);\n\t}\n  \n\t// add the ability to unsubscribe from a particular object\n\t// essentially, remove something from the observers array\n\tunsubscribe(f) {\n\t  this.observers = this.observers.filter(subscriber => subscriber !== f);\n\t}\n  \n\t// update all subscribed objects / DOM elements\n\t// and pass some data to each of them\n\tnotify(data) {\n\t  this.observers.forEach(observer => observer(data));\n\t}\n  }\n\nexport class UserObserver extends Observable {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.cache = new LRU(50);\n\t}\n\n\tasync sync(id) {\n\t\tif (this.stream) {\n\t\t\tthis.stream.close();\n\t\t}\n\n\t\tif (this.cache.has(id)) {\n\t\t\treturn this.cache.get(id);\n\t\t}\n\n\t\tconst user = await usersCollection.find({ _id: id }).first();\n\t\tthis.cache.set(id, user);\n\t\tconsole.log(this.cache.keys());\n\t\tthis.stream = await usersCollection.watch(this.cache.keys());\n\t\tthis.stream.onNext(this.notify);\n\t\treturn user;\n\t}\n}\n\nexport const usersObserver = new UserObserver();\n\nexport function ChannelMessage(_id, ownerId, channelId, content, sentAt, remoteTimestamp) {\n\treturn { _id, ownerId, channelId, content, sentAt, remoteTimestamp };\n}\n\nexport class ChannelMessageObserver extends Observable {\n\tasync sync(ids) {\n\t\tif (this.stream) {\n\t\t\tthis.stream.close();\n\t\t}\n\t\t(await channelMessagesCollection.find({_id: { $in: ids }}).asArray()).forEach((msg) => {\n\t\t\tthis.notify({fullDocument: msg, operationType: \"insert\"})\n\t\t});\n\t\tthis.stream = await channelMessagesCollection.watch(ids);\n\t\tthis.stream.onNext(this.notify);\n\t}\n}\n\nexport const channelMessageObserver = new ChannelMessageObserver();\n\nexport function ChannelSubscription(_id, channelId, ownerId, subscriptionId, localTimestamp, remoteTimestamp) {\n\treturn {\n\t\t_id, channelId, ownerId, deviceId: subscriptionId, localTimestamp, remoteTimestamp \n\t};\n}\n\nexport class ChannelSubscriptionObserver extends Observable {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tasync updateLocalVector(documentId, subscription) {\n\t\t// fetch latest message ids from logical time vector\n        const latestMessageIds = (await channelMessagesCollection.find({\n                    channelId: subscription.channelId,\n                    remoteTimestamp: {\n                        $gt: subscription.localTimestamp,\n                        $lte: subscription.remoteTimestamp\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.asArray())\n\t\t\t\t.map(it => it[\"_id\"])\n\t\t\t\t\n        await channelMessageObserver.sync(latestMessageIds)\n\n        await channelSubscriptionsCollection.updateOne(\n            { _id: documentId },\n            { $set : { localTimestamp: subscription.localTimestamp }}\n        )\n\t}\n\n\tasync notify(data) {\n\t\tconsole.log(\"New event!\");\n\t\tconsole.log(data);\n\t\tconst subscription = data.fullDocument\n\n        if (data.operationType != \"insert\"\n            || subscription == null\n            || subscription.localTimestamp == subscription.remoteTimestamp) {\n            return\n        }\n\n        await this.updateLocalVector(data.documentKey[\"_id\"], subscription)\n\n\t\tsuper.notify(data);\n\t}\n\n\tasync sync(id) {\n\t\t// this.stream.close();\n\t\tconst sub = await channelSubscriptionsCollection.find({_id: id }).first();\n\t\tawait this.updateLocalVector(id, sub);\n\t\tthis.stream = await channelSubscriptionsCollection.watch([id]);\n\t\tthis.stream.onNext((data) => { this.notify(data) });\n\t}\n}\n\nexport const channelSubscriptionObserver = new ChannelSubscriptionObserver();"]},"metadata":{},"sourceType":"module"}